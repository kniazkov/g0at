/**
 * @file parser.h
 * @copyright 2025 Ivan Kniazkov
 * @brief Defines structures and function prototypes for the parser.
 *
 * This file contains the definition of structures and function prototypes for the parser,
 * which transforms a stream of tokens generated by the scanner into an abstract syntax tree (AST).
 * The parser validates the syntactic correctness of the input and prepares data
 * for further analysis, transformation, or bytecode generation.
 */

#pragma once

#include "scanner/scanner.h"
#include "graph/statement.h"
#include "compilation_error.h"

/**
 * @typedef reduce_rule_t
 * @brief Function pointer type for token reduction rules in a bottom-up parser.
 * 
 * A reduction rule is a function that performs a reduction operation in a bottom-up parser. 
 * It processes tokens starting from a given token and may create new tokens and syntax tree 
 * nodes during the reduction process. If a syntax error occurs during the reduction, the 
 * function returns a pointer to a `compilation_error_t` structure describing the error.
 * 
 * The memory for the `compilation_error_t` structures is allocated from the same memory 
 * arena used for tokens (`memory->tokens`). This ensures that memory management is centralized 
 * and efficient. Errors can be linked together to form a chain using the `next` field, and 
 * the entire chain is deallocated automatically when the token memory arena is destroyed.
 * 
 * @param start_token The token where the reduction starts.
 * @param memory A pointer to the `parser_memory_t` structure, which manages memory allocation
 *  for tokens and syntax tree nodes.
 * @param groups Token classification groups that may be updated during reduction.
 * 
 * @return A pointer to a `compilation_error_t` if a syntax error occurs, or `NULL` if the rule 
 *  was successfully applied.
 */
typedef compilation_error_t* (*reduce_rule_t)(token_t *start_token, parser_memory_t *memory,
        token_groups_t *groups);

/**
 * @brief Processes tokens and analyzes bracket pairs, storing the result in the provided
 *  token list.
 * 
 * This function creates a list of tokens and processes them using `scan_and_analyze_for_brackets`, 
 * transforming balanced bracket pairs into special `TOKEN_BRACKET_PAIR` tokens. The resulting
 * tokens are stored in the lists pointed to by `tokens`. If any errors are encountered
 * during the scanning process, they are returned.
 * 
 * @param arena The memory arena for allocating tokens.
 * @param scan The scanner used to get the tokens.
 * @param tokens A pointer to token list where the processed tokens will be stored.
 * @note Any error returned by this function is considered critical and prevents further parsing.
 *  For example, unmatched brackets or invalid tokens within brackets are treated as structural
 *  issues that require immediate attention.
 * @return A `compilation_error_t` pointer if an error is detected (e.g., mismatched brackets),
 *  or NULL if no errors.
 */
compilation_error_t *process_brackets(arena_t *arena, scanner_t *scan, token_list_t *tokens);

/**
 * @brief Collapses a sequence of tokens into a single token.
 * 
 * This function takes a sequence of tokens, specified by the `first` and `last` tokens, and merges
 * them into a single token of the specified type. The new token will span the range of positions
 * from the `begin` position of the `first` token to the `end` position of the `last` token.
 * The function also associates the new token with the provided abstract syntax tree node (`node`).
 * 
 * After collapsing the tokens, the old tokens are removed from the token list, and the new token
 * is inserted in their place, maintaining the linkage of surrounding tokens.
 * 
 * @param arena The memory arena to allocate the new token.
 * @param first The first token in the sequence to collapse.
 * @param last The last token in the sequence to collapse.
 * @param type The type of the new token.
 * @param node The AST node associated with the new token.
 * @return A pointer to the newly created token that represents the collapsed sequence.
 * 
 * @note The `first` and `last` tokens must belong to the same sequence and will be removed 
 *  from the token list during the collapse process. The new token will replace the sequence
 *  of tokens in the list.
 */
token_t *collapse_tokens_to_token(arena_t *arena, token_t *first, token_t *last,
        token_type_t type, node_t *node);

/**
 * @struct statement_list_processing_result_t
 * @brief A structure representing the result of processing a list of statements.
 * 
 * This structure holds the processed statements, the number of statements,
 * and any error that may have occurred during the processing.
 */
typedef struct {
    /**
     * @brief An array of statement nodes.
     */
    statement_t **list;

    /**
     * @brief The number of statements in the list.
     */
    size_t count;

    /**
     * @brief A pointer to a compilation error, if any.
     */
    compilation_error_t *error;
} statement_list_processing_result_t;

/**
 * @brief Processes a list of tokens and attempts to create statements from them.
 * 
 * This function iterates over a list of tokens, identifies statement tokens, and converts
 * them into a list of statements. If an expression token is encountered, it is wrapped as
 * a statement. If any error occurs (e.g., invalid token), the process stops and the error
 * is stored in the result.
 * 
 * @param memory A pointer to the parser's memory structure, used for memory allocation.
 * @param tokens A pointer to the list of tokens to be processed.
 * 
 * @return A `statement_list_processing_result_t` structure containing the processed
 *  statements, the total count of statements, and any compilation error encountered.
 */
statement_list_processing_result_t process_statement_list(parser_memory_t *memory,
        token_list_t *tokens);

/**
 * @brief Applies reduction rules to a sequence of token groups.
 * 
 * This function processes a set of token groups and applies the appropriate reduction rules 
 * to transform token sequences into more abstract representations, such as syntax tree (AST)
 * nodes. Each token group is passed through a series of reduction rules, which reduce the tokens 
 * to higher-level constructs.
 * 
 * The function iterates over all token groups and applies each reduction rule in sequence.
 * If any syntax errors are encountered, they are accumulated into a linked list of 
 * `compilation_error_t` structures. The function does not always stop processing after the 
 * first error; instead, it attempts to continue applying reduction rules to find and report 
 * as many errors as possible in a single pass.
 * 
 * @param groups A pointer to the token groups to which the reduction rules will be applied.
 * @param memory A pointer to the `parser_memory_t` structure, which manages memory allocation
 *  for tokens and syntax tree nodes.
 * @return A pointer to the last `compilation_error_t` in the chain of errors, or `NULL`
 *  if no errors occurred. The returned error points to the head of the linked list of errors via
 *  its `next` field.
 * 
 * @note This function assumes that the token groups have been initialized and populated
 *       during the lexical analysis phase.
 * @note The caller is responsible for iterating through the linked list of errors and 
 *       handling or logging each error as needed.
 */
compilation_error_t *apply_reduction_rules(token_groups_t *groups, parser_memory_t *memory);

/**
 * @brief Processes the root-level token list and constructs a syntax tree root node.
 * 
 * This function takes a list of tokens, processes it to extract statements, and creates
 * a root node for the syntax tree. If an error occurs while processing the token list, it is
 * captured in the result.
 * 
 * @param memory A pointer to the parser's memory structure, used for memory allocation.
 * @param tokens A pointer to the list of tokens to be processed at the root level.
 * @param root_node A pointer to the root node of the syntax tree that will be created
 *  by this function.
 * 
 * @return A `compilation_error_t` structure containing any compilation error encountered
 *         during the processing, or `NULL` if no error occurred.
 */
compilation_error_t *process_root_token_list(parser_memory_t *memory,
        token_list_t *tokens, node_t **root_node);
