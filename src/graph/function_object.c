/**
 * @file function_object.c
 * @copyright 2025 Ivan Kniazkov
 * @brief Implementation of function object expressions.
 * 
 * This file defines the behavior of function object expressions in the abstract syntax tree (AST).
 * A function object consists of a parameter list (identifiers) and a function body.
 * When evaluated, it produces a callable function value capturing the current context.
 */

 #include <assert.h>

#include "common_methods.h"
#include "expression.h"
#include "statement.h"
#include "lib/allocate.h"
#include "lib/arena.h"
#include "lib/string_ext.h"
#include "codegen/code_builder.h"
#include "codegen/data_builder.h"
#include "codegen/source_builder.h"

/**
 * @struct function_object_t
 * @brief Represents a function object expression in the AST.
 * 
 * This structure defines a function expression node that encapsulates a list
 * of parameter names and a function body. When evaluated, it produces a function
 * value that can be called with arguments.
 */
typedef struct {
    /**
     * @brief Base expression structure from which function_object_t inherits.
     * 
     * This allows the node to be treated as an expression in the AST while
     * providing the necessary functionality for tree traversal and manipulation.
     */
    expression_t base;

    /**
     * @brief List of function parameter names.
     * 
     * Each entry is a string view representing a parameter identifier.
     */
    string_view_t *arg_list;

    /**
     * @brief Number of function parameters.
     */
    size_t arg_count;

    /**
     * @brief List of statements forming the function body.
     * 
     * This is an array of pointers to statement nodes that make up the function's logic.
     */
    statement_t **stmt_list;

    /**
     * @brief Number of statements in the function body.
     */
    size_t stmt_count;

    /**
     * @brief Index of the `ARG` instruction containing index of the first instruction 
     *  of the function body.
     * 
     * This points to the entry instruction in the generated bytecode,
     * used when the function is called.
     */
    instr_index_t code_instr_index;
} function_object_t;

/**
 * @brief Retrieves a string representation of the function's parameter list.
 *
 * This implementation of the `get_data` method for function object nodes returns
 * a comma-separated list of parameter names. If the function has no parameters,
 * an empty string is returned.
 *
 * @param node Pointer to the function object node.
 * @return A `string_value_t` containing the list of parameter names as a string.
 */
static string_value_t get_data(const node_t *node) {
    const function_object_t *expr = (const function_object_t *)node;
    string_value_t result = EMPTY_STRING_VALUE;
    string_builder_t builder;
    init_string_builder(&builder, 0);
    for (size_t index = 0; index < expr->arg_count; index++) {
        if (index > 0) {
            append_static_string(&builder, L", ");
        }
        result = append_string_view(&builder, expr->arg_list[index]);
    }
    return result;
}

/**
 * @brief Gets the number of child statements in a function object.
 * @param node Pointer to the function object node.
 * @return Number of statements in the function body (0 if empty).
 */
static size_t get_child_count(const node_t *node) {
    const function_object_t* expr = (const function_object_t*)node;
    return expr->stmt_count;
}

/**
 * @brief Retrieves a specific child statement from a function object.
 * 
 * Accesses the function's body by index with bounds checking.
 * Valid indices range from 0 to stmt_count - 1.
 * 
 * @param node Pointer to the function object node.
 * @param index Zero-based index of the statement.
 * @return Pointer to the statement node, or NULL if index is out of bounds.
 */
static const node_t* get_child(const node_t *node, size_t index) {
    const function_object_t* expr = (const function_object_t*)node;
    if (index >= expr->stmt_count) {
        return NULL;
    }
    return &expr->stmt_list[index]->base;
}

/**
 * @brief Generates the function header in Goat syntax.
 *
 * Constructs a string like `func(arg1, arg2, ...) {` using the parameter list
 * from the given function object. Appends the result to the provided string builder.
 *
 * @param expr Pointer to the function object expression.
 * @param builder Pointer to the string builder used to accumulate the output.
 * @return The resulting string after appending the header.
 */
static string_value_t generate_header(const function_object_t* expr, string_builder_t *builder) {
    append_static_string(builder, L"func(");
    for (size_t index = 0; index < expr->arg_count; index++) {
        if (index > 0) {
            append_static_string(builder, L", ");
        }
        append_string_view(builder, expr->arg_list[index]);
    }
    return append_static_string(builder, L") {");
}

/**
 * @brief Converts a function object node to its compact Goat syntax representation.
 * 
 * Generates a single-line canonical Goat representation of the function, including:
 * - The function keyword with its parameters: `func(arg1, arg2, ...)`
 * - A block body with all statements concatenated and space-separated
 * 
 * Example: `func(x, y) { return x + y }`
 * 
 * @param node Pointer to the function object node.
 * @return `string_value_t` containing the generated code.
 */
static string_value_t generate_goat_code(const node_t *node) {
    const function_object_t* expr = (const function_object_t*)node;
    string_builder_t builder;
    init_string_builder(&builder, 128);
    generate_header(expr, &builder);
    for (size_t index = 0; index < expr->stmt_count; index++) {
        if (index > 0) {
            append_char(&builder, L' ');
        }
        statement_t *stmt = expr->stmt_list[index];
        string_value_t stmt_as_string = stmt->base.vtbl->generate_goat_code(&stmt->base);
        append_string_value(&builder, stmt_as_string);
        FREE_STRING(stmt_as_string);
    }
    return append_char(&builder, L'}');
}

/**
 * @brief Generates a multi-line, indented Goat source code representation of the function.
 * 
 * Produces a human-readable version of the function definition with proper formatting:
 * - Header and braces placed on separate lines
 * - Statements indented according to nesting level
 * - Supports arbitrary levels of indentation
 * 
 * Example output:
 * ```
 * func(x, y) {
 *     return x + y
 * }
 * ```
 *
 * @param node Pointer to the function object node.
 * @param builder Output accumulator for the generated source code.
 * @param indent Base indentation level (number of tabs).
 */
static void generate_indented_goat_code(const node_t *node, source_builder_t *builder,
        size_t indent) {
    const function_object_t* expr = (const function_object_t*)node;
    string_builder_t header;
    init_string_builder(&header, 16);
    append_formatted_source(builder, generate_header(expr, &header));
    for (size_t index = 0; index < expr->stmt_count; index++) {
        statement_t *stmt = expr->stmt_list[index];
        stmt->base.vtbl->generate_indented_goat_code(&stmt->base, builder, indent + 1);
    }
    add_static_source(builder, indent, L"}");
}

/**
 * @brief Generates the main bytecode for a function object expression.
 * 
 * This function emits the initial instruction(s) required to represent a function object
 * in the bytecode stream. It prepares a placeholder instruction (`ARG`) for body address
 * and emits a  `FUNC` instruction with encoded parameter information.
 * 
 * The actual function body is not generated here â€” that is handled by `generate_bytecode_deferred`.
 * 
 * @param node A pointer to the function object node.
 * @param code A pointer to the bytecode builder.
 * @param data A pointer to the static data segment builder.
 * @return The instruction index of the first emitted instruction.
 */
static instr_index_t generate_bytecode(node_t *node, code_builder_t *code,
        data_builder_t *data) {
    function_object_t* expr = (function_object_t*)node;
    instr_index_t first = expr->code_instr_index = add_instruction(
        code,
        (instruction_t){ .opcode = ARG, .arg1 = 0xFFFFFFFF } // placeholder
    );
    uint32_t arg_names_idx = 0;
    if (expr->arg_count > 0) {
        size_t arg_size = expr->arg_count * sizeof(uint32_t);
        uint32_t *arg_names = (uint32_t*)ALLOC(arg_size);
        for (size_t index = 0; index < expr->arg_count; index++) {
            arg_names[index] = add_string_to_data_segment_ex(data, expr->arg_list[index]);
        }
        arg_names_idx = add_data_to_data_segment(data, arg_names, arg_size);
        FREE(arg_names);
    }
    add_instruction(
        code,
        (instruction_t) {
            .opcode = FUNC,
            .arg0 = (uint16_t)expr->arg_count,
            .arg1 = arg_names_idx
        }
    );
    return first;
}

/**
 * @brief Attempts to generate deferred bytecode for a function object's body.
 *
 * Emits the bytecode instructions that implement the function body. This is
 * invoked separately from the main (non-deferred) codegen phase so that
 * function definitions can exist before their bodies are emitted.
 *
 * Readiness & multi-pass behavior:
 * - If the call site / jump placeholder for this function is not yet known
 *   (i.e., there is no valid instruction slot to patch with the entry address),
 *   the function returns `false` and emits nothing. The caller should
 *   schedule another pass later.
 * - When the placeholder is known, the function emits the body and patches
 *   the previously reserved instruction with the entry point; in this case
 *   it returns `true`.
 *
 * @param node Pointer to the function object node.
 * @param code Bytecode builder that receives emitted instructions.
 * @param data Static data (constant pool) builder.
 * @return `true` if the function body was emitted and the call site patched;
 *  `false` if required information is missing and another pass is needed.
 */
static bool generate_bytecode_deferred(const node_t *node, code_builder_t *code,
        data_builder_t *data) {
    function_object_t* expr = (function_object_t*)node;
    if (expr->code_instr_index == BAD_INSTR_INDEX) {
        return false;
    }
    instr_index_t first;
    if (expr->stmt_count == 0) {
        first = add_instruction(code, (instruction_t){ .opcode = NIL });
        add_instruction(code, (instruction_t){ .opcode = RET });        
    }
    else {
        first = expr->stmt_list[0]->base.vtbl->generate_bytecode(&expr->stmt_list[0]->base,
            code, data);
        for (size_t index = 1; index < expr->stmt_count; index++) {
            statement_t *stmt = expr->stmt_list[index];
            stmt->base.vtbl->generate_bytecode(&stmt->base, code, data);
        }
        if (expr->stmt_list[expr->stmt_count - 1]->base.vtbl->type != NODE_RETURN) {
            add_instruction(code, (instruction_t){ .opcode = NIL });
            add_instruction(code, (instruction_t){ .opcode = RET });
        }
    }
    code->instructions[expr->code_instr_index].arg1 = (uint32_t)first;
    return true;
}

/**
 * @brief Virtual table for function object node operations.
 * 
 * This virtual table provides the implementation of operations specific to function object nodes
 * in the abstract syntax tree (AST).
 */
static node_vtbl_t fo_vtbl = {
    .type = NODE_FUNCTION_OBJECT,
    .type_name = L"function object",
    .get_data = get_data,
    .get_child_count = get_child_count,
    .get_child = get_child,
    .get_child_tag = no_tags,
    .generate_goat_code = generate_goat_code,
    .generate_indented_goat_code = generate_indented_goat_code,
    .generate_bytecode = generate_bytecode,
    .generate_bytecode_deferred = generate_bytecode_deferred
};

node_t *create_function_object_node(arena_t *arena, string_view_t *arg_list, size_t arg_count) {
    function_object_t *fobj = (function_object_t*)alloc_zeroed_from_arena(arena,
        sizeof(function_object_t));
    fobj->base.base.vtbl = &fo_vtbl;
    if (arg_count > 0) {
        fobj->arg_list = (string_view_t*)alloc_from_arena(arena, sizeof(string_view_t) * arg_count);
        for (size_t index = 0; index < arg_count; index++) {
            fobj->arg_list[index] = copy_string_to_arena(arena, arg_list[index].data,
                arg_list[index].length);
        }
        fobj->arg_count = arg_count;
    }
    return &fobj->base.base;
}

void fill_function_body(node_t *node, arena_t *arena, statement_t **stmt_list, size_t stmt_count) {
    assert(node->vtbl->type == NODE_FUNCTION_OBJECT);
    function_object_t *fobj = (function_object_t *)node;
    size_t data_size = stmt_count * sizeof(statement_t *);
    fobj->stmt_list = (statement_t **)alloc_from_arena(arena, data_size);
    memcpy(fobj->stmt_list, stmt_list, data_size);
    fobj->stmt_count = stmt_count;
    fobj->code_instr_index = BAD_INSTR_INDEX;
}
