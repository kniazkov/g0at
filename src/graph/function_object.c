/**
 * @file function_object.c
 * @copyright 2025 Ivan Kniazkov
 * @brief Implementation of function object expressions.
 * 
 * This file defines the behavior of function object expressions in the abstract syntax tree (AST).
 * A function object consists of a parameter list (identifiers) and a function body.
 * When evaluated, it produces a callable function value capturing the current context.
 */

 #include <assert.h>

#include "common_methods.h"
#include "expression.h"
#include "statement.h"
#include "lib/allocate.h"
#include "lib/arena.h"
#include "lib/string_ext.h"
#include "codegen/code_builder.h"
#include "codegen/data_builder.h"
#include "codegen/source_builder.h"

/**
 * @struct function_object_t
 * @brief Represents a function object expression in the AST.
 * 
 * This structure defines a function expression node that encapsulates a list
 * of parameter names and a function body. When evaluated, it produces a function
 * value that can be called with arguments.
 */
typedef struct {
    /**
     * @brief Base expression structure from which function_object_t inherits.
     * 
     * This allows the node to be treated as an expression in the AST while
     * providing the necessary functionality for tree traversal and manipulation.
     */
    expression_t base;

    /**
     * @brief List of function parameter names.
     * 
     * Each entry is a string view representing a parameter identifier.
     */
    string_view_t *arg_list;

    /**
     * @brief Number of function parameters.
     */
    size_t arg_count;

    /**
     * @brief List of statements forming the function body.
     * 
     * This is an array of pointers to statement nodes that make up the function's logic.
     */
    statement_t **stmt_list;

    /**
     * @brief Number of statements in the function body.
     */
    size_t stmt_count;

    /**
     * @brief Index of the `ARG` instruction containing index of the first instruction 
     *  of the function body.
     * 
     * This points to the entry instruction in the generated bytecode,
     * used when the function is called.
     */
    instr_index_t code_instr_index;
} function_object_t;

/**
 * @brief Retrieves a string representation of the function's parameter list.
 *
 * This implementation of the `get_data` method for function object nodes returns
 * a comma-separated list of parameter names. If the function has no parameters,
 * an empty string is returned.
 *
 * @param node Pointer to the function object node.
 * @return A `string_value_t` containing the list of parameter names as a string.
 */
static string_value_t get_data(const node_t *node) {
    const function_object_t *expr = (const function_object_t *)node;
    string_value_t result = EMPTY_STRING_VALUE;
    string_builder_t builder;
    init_string_builder(&builder, 0);
    for (size_t index = 0; index < expr->arg_count; index++) {
        if (index > 0) {
            append_static_string(&builder, L", ");
        }
        result = append_string_view(&builder, expr->arg_list[index]);
    }
    return result;
}

/**
 * @brief Gets the number of child statements in a function object.
 * @param node Pointer to the function object node.
 * @return Number of statements in the function body (0 if empty).
 */
static size_t get_child_count(const node_t *node) {
    const function_object_t* expr = (const function_object_t*)node;
    return expr->stmt_count;
}

/**
 * @brief Retrieves a specific child statement from a function object.
 * 
 * Accesses the function's body by index with bounds checking.
 * Valid indices range from 0 to stmt_count - 1.
 * 
 * @param node Pointer to the function object node.
 * @param index Zero-based index of the statement.
 * @return Pointer to the statement node, or NULL if index is out of bounds.
 */
static const node_t* get_child(const node_t *node, size_t index) {
    const function_object_t* expr = (const function_object_t*)node;
    if (index >= expr->stmt_count) {
        return NULL;
    }
    return &expr->stmt_list[index]->base;
}

/**
 * @brief Generates the function header in Goat syntax.
 *
 * Constructs a string like `func(arg1, arg2, ...) {` using the parameter list
 * from the given function object. Appends the result to the provided string builder.
 *
 * @param expr Pointer to the function object expression.
 * @param builder Pointer to the string builder used to accumulate the output.
 * @return The resulting string after appending the header.
 */
static string_value_t generate_header(const function_object_t* expr, string_builder_t *builder) {
    append_static_string(builder, L"func(");
    for (size_t index = 0; index < expr->arg_count; index++) {
        if (index > 0) {
            append_static_string(builder, L", ");
        }
        append_string_view(builder, expr->arg_list[index]);
    }
    return append_static_string(builder, L") {");
}

/**
 * @brief Converts a function object node to its compact Goat syntax representation.
 * 
 * Generates a single-line canonical Goat representation of the function, including:
 * - The function keyword with its parameters: `func(arg1, arg2, ...)`
 * - A block body with all statements concatenated and space-separated
 * 
 * Example: `func(x, y) { return x + y }`
 * 
 * @param node Pointer to the function object node.
 * @return `string_value_t` containing the generated code.
 */
static string_value_t generate_goat_code(const node_t *node) {
    const function_object_t* expr = (const function_object_t*)node;
    string_builder_t builder;
    init_string_builder(&builder, 128);
    generate_header(expr, &builder);
    for (size_t index = 0; index < expr->stmt_count; index++) {
        if (index > 0) {
            append_char(&builder, L' ');
        }
        statement_t *stmt = expr->stmt_list[index];
        string_value_t stmt_as_string = stmt->base.vtbl->generate_goat_code(&stmt->base);
        append_string_value(&builder, stmt_as_string);
        FREE_STRING(stmt_as_string);
    }
    return append_char(&builder, L'}');
}

/**
 * @brief Generates a multi-line, indented Goat source code representation of the function.
 * 
 * Produces a human-readable version of the function definition with proper formatting:
 * - Header and braces placed on separate lines
 * - Statements indented according to nesting level
 * - Supports arbitrary levels of indentation
 * 
 * Example output:
 * ```
 * func(x, y) {
 *     return x + y
 * }
 * ```
 *
 * @param node Pointer to the function object node.
 * @param builder Output accumulator for the generated source code.
 * @param indent Base indentation level (number of tabs).
 */
static void generate_indented_goat_code(const node_t *node, source_builder_t *builder,
        size_t indent) {
    const function_object_t* expr = (const function_object_t*)node;
    string_builder_t header;
    init_string_builder(&header, 16);
    add_formatted_source(builder, indent, generate_header(expr, &header));
    for (size_t index = 0; index < expr->stmt_count; index++) {
        statement_t *stmt = expr->stmt_list[index];
        stmt->base.vtbl->generate_indented_goat_code(&stmt->base, builder, indent + 1);
    }
    add_static_source(builder, indent, L"}");
}

static instr_index_t generate_bytecode(node_t *node, code_builder_t *code,
        data_builder_t *data) {
    function_object_t* expr = (function_object_t*)node;
    instr_index_t first = expr->code_instr_index = add_instruction(
        code,
        (instruction_t){ .opcode = ARG, .arg1 = 0xFFFFFFFF } // placeholder
    );
    uint32_t arg_names_idx = 0;
    if (expr->arg_count > 0) {
        size_t arg_size = expr->arg_count * sizeof(uint32_t);
        uint32_t *arg_names = (uint32_t)ALLOC(arg_size);
        for (size_t index = 0; index < expr->arg_count; index++) {
            arg_names[index] = add_string_to_data_segment_ex(data, expr->arg_list[index]);
        }
        arg_names_idx = add_data_to_data_segment(data, arg_names, arg_size);
        FREE(arg_names);
    }
    add_instruction(
        code,
        (instruction_t) {
            .opcode = FUNC,
            .arg0 = (uint16_t)expr->arg_count,
            .arg1 = arg_names_idx
        }
    );
    return first;
}

static instr_index_t generate_bytecode_deferred(const node_t *node, code_builder_t *code,
        data_builder_t *data) {
    function_object_t* expr = (function_object_t*)node;
    instr_index_t first;
    if (expr->stmt_count == 0) {
        first = add_instruction(code, (instruction_t){ .opcode = NIL });
        add_instruction(code, (instruction_t){ .opcode = RET });        
    }
    else {
        first = expr->stmt_list[0]->base.vtbl->generate_bytecode(&expr->stmt_list[0]->base,
            code, data);
        for (size_t index = 1; index < expr->stmt_count; index++) {
            statement_t *stmt = expr->stmt_list[index];
            stmt->base.vtbl->generate_bytecode(&stmt->base, code, data);
        }
        add_instruction(code, (instruction_t){ .opcode = NIL });
        add_instruction(code, (instruction_t){ .opcode = RET });
    }
    return first;
}
